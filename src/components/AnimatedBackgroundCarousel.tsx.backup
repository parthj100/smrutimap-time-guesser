
import React, { useEffect, useState } from 'react';
import { getAllImages } from '@/data/sampleData';
import { GameImage } from '@/types/game';

const AnimatedBackgroundCarousel: React.FC = () => {
  const [images, setImages] = useState<GameImage[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadImages = async () => {
      try {
        console.log('ðŸŽ  Loading images for carousel...');
        const allImages = await getAllImages();
        if (allImages.length > 0) {
          // Shuffle and duplicate images for seamless looping
          const shuffled = [...allImages].sort(() => Math.random() - 0.5);
          
          // Preload first few images for faster initial display
          const preloadPromises = shuffled.slice(0, 12).map(image => {
            return new Promise((resolve) => {
              const img = new Image();
              img.onload = resolve;
              img.onerror = resolve; // Continue even if some images fail
              img.src = image.image_url;
            });
          });
          
          // Wait for initial images to preload
          await Promise.all(preloadPromises);
          
          setImages(shuffled);
          console.log(`âœ… Loaded ${shuffled.length} images for carousel`);
        }
      } catch (error) {
        console.error('Failed to load images for carousel:', error);
      } finally {
        setLoading(false);
      }
    };

    loadImages();
  }, []);

  if (loading) {
    return (
      <div className="fixed inset-0 overflow-hidden pointer-events-none z-0 bg-gradient-to-br from-gray-100 to-gray-200 opacity-30" />
    );
  }

  if (images.length === 0) {
    return null;
  }

  // Create multiple columns with different images and directions
  const createColumn = (columnIndex: number) => {
    const columnImages = images.filter((_, index) => index % 4 === columnIndex);
    
    // Create enough duplicates for seamless infinite loop - 4 sets should be enough
    const quadruplicatedImages = [
      ...columnImages, 
      ...columnImages, 
      ...columnImages, 
      ...columnImages
    ];
    
    // Determine direction: columns 0,2 go up; columns 1,3 go down
    const isUpward = columnIndex % 2 === 0;
    
    // Different animation speeds - leftmost (0) is slowest, progressively faster
    const animationDuration = 360 - columnIndex * 30; // 360s, 330s, 300s, 270s

    // Calculate centered column positioning
    const columnWidth = 18; // 18% width per column
    const gapWidth = 2; // 2% gap between columns
    const totalWidth = (columnWidth * 4) + (gapWidth * 3); // Total width of all columns + gaps
    const startOffset = (100 - totalWidth) / 2; // Center the entire layout
    const leftPosition = startOffset + (columnIndex * (columnWidth + gapWidth));

    return (
      <div
        key={columnIndex}
        className="absolute flex flex-col"
        style={{
          left: `${leftPosition}%`,
          width: `${columnWidth}%`,
          gap: '8px', // Reduced gap for tighter spacing
          animation: `infiniteScroll${isUpward ? 'Up' : 'Down'} ${animationDuration}s linear infinite`,
        }}
      >
        {quadruplicatedImages.map((image, index) => (
          <div
            key={`${image.id}-${index}`}
            className="relative overflow-hidden rounded-lg flex-shrink-0"
            style={{ height: '200px' }} // Slightly smaller for better fit
          >
            <img
              src={image.image_url}
              alt={image.description}
              className="w-full h-full object-cover opacity-40 blur-[1px] transition-opacity duration-300"
              loading="lazy"
              onError={(e) => {
                // Hide broken images
                e.currentTarget.style.display = 'none';
              }}
            />
          </div>
        ))}
      </div>
    );
  };

  return (
    <div className="fixed inset-0 overflow-hidden pointer-events-none z-0">
      <style>{`
        /* Unified upward animation - starts from bottom, moves to top */
        @keyframes infiniteScrollUp {
          0% { 
            transform: translateY(100vh); 
          }
          100% { 
            transform: translateY(-100%); 
          }
        }
        
        /* Unified downward animation - starts from top, moves to bottom */
        @keyframes infiniteScrollDown {
          0% { 
            transform: translateY(-100%); 
          }
          100% { 
            transform: translateY(100vh); 
          }
        }
      `}</style>
      
      {/* Create 4 columns with synchronized start and seamless loops */}
      {createColumn(0)}      {/* Left - Up - Slowest (360s) */}
      {createColumn(1)}      {/* Second - Down - (330s) */}
      {createColumn(2)}      {/* Third - Up - (300s) */}
      {createColumn(3)}      {/* Right - Down - Fastest (270s) */}
    </div>
  );
};

export default AnimatedBackgroundCarousel;
